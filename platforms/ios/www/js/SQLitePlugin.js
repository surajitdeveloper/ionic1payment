(function(){var DB_STATE_INIT,DB_STATE_OPEN,READ_ONLY_REGEX,SQLiteFactory,SQLitePlugin,SQLitePluginTransaction,argsArray,dblocations,newSQLError,nextTick,root,txLocks;root=this,READ_ONLY_REGEX=/^\s*(?:drop|delete|insert|update|create)\s/i,DB_STATE_INIT="INIT",DB_STATE_OPEN="OPEN",txLocks={},newSQLError=function(error,code){var sqlError;return sqlError=error,code||(code=0),sqlError||(sqlError=new Error("a plugin had an error but provided no response"),sqlError.code=code),"string"==typeof sqlError&&(sqlError=new Error(error),sqlError.code=code),!sqlError.code&&sqlError.message&&(sqlError.code=code),sqlError.code||sqlError.message||(sqlError=new Error("an unknown error was returned: "+JSON.stringify(sqlError)),sqlError.code=code),sqlError},nextTick=window.setImmediate||function(fun){window.setTimeout(fun,0)},argsArray=function(fun){return function(){var args,i,len;if(len=arguments.length){for(args=[],i=-1;++i<len;)args[i]=arguments[i];return fun.call(this,args)}return fun.call(this,[])}},SQLitePlugin=function(openargs,openSuccess,openError){var dbname;if(!openargs||!openargs.name)throw newSQLError("Cannot create a SQLitePlugin db instance without a db name");dbname=openargs.name,this.openargs=openargs,this.dbname=dbname,this.openSuccess=openSuccess,this.openError=openError,this.openSuccess||(this.openSuccess=function(){}),this.openError||(this.openError=function(e){}),this.open(this.openSuccess,this.openError)},SQLitePlugin.prototype.databaseFeatures={isSQLitePluginDatabase:!0},SQLitePlugin.prototype.openDBs={},SQLitePlugin.prototype.addTransaction=function(t){txLocks[this.dbname]||(txLocks[this.dbname]={queue:[],inProgress:!1}),txLocks[this.dbname].queue.push(t),this.dbname in this.openDBs&&this.openDBs[this.dbname]!==DB_STATE_INIT?this.startNextTransaction():this.dbname in this.openDBs},SQLitePlugin.prototype.transaction=function(fn,error,success){return this.openDBs[this.dbname]?void this.addTransaction(new SQLitePluginTransaction(this,fn,error,success,!0,!1)):void error(newSQLError("database not open"))},SQLitePlugin.prototype.readTransaction=function(fn,error,success){return this.openDBs[this.dbname]?void this.addTransaction(new SQLitePluginTransaction(this,fn,error,success,!0,!0)):void error(newSQLError("database not open"))},SQLitePlugin.prototype.startNextTransaction=function(){var self;self=this,nextTick(function(_this){return function(){var txLock;_this.dbname in _this.openDBs&&_this.openDBs[_this.dbname]===DB_STATE_OPEN&&(txLock=txLocks[self.dbname],txLock&&txLock.queue.length>0&&!txLock.inProgress&&(txLock.inProgress=!0,txLock.queue.shift().start()))}}(this))},SQLitePlugin.prototype.abortAllPendingTransactions=function(){var tx,txLock,_i,_len,_ref;if(txLock=txLocks[this.dbname],txLock&&txLock.queue.length>0){for(_ref=txLock.queue,_i=0,_len=_ref.length;_len>_i;_i++)tx=_ref[_i],tx.abortFromQ(newSQLError("Invalid database handle"));txLock.queue=[],txLock.inProgress=!1}},SQLitePlugin.prototype.open=function(success,error){var openerrorcb,opensuccesscb;this.dbname in this.openDBs?nextTick(function(_this){return function(){success(_this)}}(this)):(opensuccesscb=function(_this){return function(){var txLock;!_this.openDBs[_this.dbname],_this.dbname in _this.openDBs&&(_this.openDBs[_this.dbname]=DB_STATE_OPEN),success&&success(_this),txLock=txLocks[_this.dbname],txLock&&txLock.queue.length>0&&!txLock.inProgress&&_this.startNextTransaction()}}(this),openerrorcb=function(_this){return function(){error&&error(newSQLError("Could not open database")),delete _this.openDBs[_this.dbname],_this.abortAllPendingTransactions()}}(this),this.openDBs[this.dbname]=DB_STATE_INIT,cordova.exec(opensuccesscb,openerrorcb,"SQLitePlugin","open",[this.openargs]))},SQLitePlugin.prototype.close=function(success,error){if(this.dbname in this.openDBs){if(txLocks[this.dbname]&&txLocks[this.dbname].inProgress)return void error(newSQLError("database cannot be closed while a transaction is in progress"));delete this.openDBs[this.dbname],txLocks[this.dbname],cordova.exec(success,error,"SQLitePlugin","close",[{path:this.dbname}])}else error&&nextTick(function(){return error()})},SQLitePlugin.prototype.executeSql=function(statement,params,success,error){var myerror,myfn,mysuccess;mysuccess=function(t,r){return success?success(r):void 0},myerror=function(t,e){return error?error(e):void 0},myfn=function(tx){tx.addStatement(statement,params,mysuccess,myerror)},this.addTransaction(new SQLitePluginTransaction(this,myfn,null,null,!1,!1))},SQLitePluginTransaction=function(db,fn,error,success,txlock,readOnly){if("function"!=typeof fn)throw newSQLError("transaction expected a function");this.db=db,this.fn=fn,this.error=error,this.success=success,this.txlock=txlock,this.readOnly=readOnly,this.executes=[],txlock&&this.addStatement("BEGIN",[],null,function(tx,err){throw newSQLError("unable to begin transaction: "+err.message,err.code)})},SQLitePluginTransaction.prototype.start=function(){var err;try{this.fn(this),this.run()}catch(_error){err=_error,txLocks[this.db.dbname].inProgress=!1,this.db.startNextTransaction(),this.error&&this.error(newSQLError(err))}},SQLitePluginTransaction.prototype.executeSql=function(sql,values,success,error){if(this.finalized)throw{message:"InvalidStateError: DOM Exception 11: This transaction is already finalized. Transactions are committed after its success or failure handlers are called. If you are using a Promise to handle callbacks, be aware that implementations following the A+ standard adhere to run-to-completion semantics and so Promise resolution occurs on a subsequent tick and therefore after the transaction commits.",code:11};return this.readOnly&&READ_ONLY_REGEX.test(sql)?void this.handleStatementFailure(error,{message:"invalid sql for a read-only transaction"}):void this.addStatement(sql,values,success,error)},SQLitePluginTransaction.prototype.addStatement=function(sql,values,success,error){var params,qid,t,v,_i,_len;if(qid=this.executes.length,params=[],values&&values.constructor===Array)for(_i=0,_len=values.length;_len>_i;_i++)v=values[_i],t=typeof v,params.push(null===v||void 0===v||"number"===t||"string"===t?v:v instanceof Blob?v.valueOf():v.toString());this.executes.push({success:success,error:error,qid:qid,sql:sql,params:params})},SQLitePluginTransaction.prototype.handleStatementSuccess=function(handler,response){var payload,rows;handler&&(rows=response.rows||[],payload={rows:{item:function(i){return rows[i]},length:rows.length},rowsAffected:response.rowsAffected||0,insertId:response.insertId||void 0},handler(this,payload))},SQLitePluginTransaction.prototype.handleStatementFailure=function(handler,response){if(!handler)throw newSQLError("a statement with no error handler failed: "+response.message,response.code);if(handler(this,response)!==!1)throw newSQLError("a statement error callback did not return false: "+response.message,response.code)},SQLitePluginTransaction.prototype.run=function(){var batchExecutes,handlerFor,i,mycb,mycbmap,qid,request,tropts,tx,txFailure,waiting;for(txFailure=null,tropts=[],batchExecutes=this.executes,waiting=batchExecutes.length,this.executes=[],tx=this,handlerFor=function(index,didSucceed){return function(response){var err;try{didSucceed?tx.handleStatementSuccess(batchExecutes[index].success,response):tx.handleStatementFailure(batchExecutes[index].error,newSQLError(response))}catch(_error){err=_error,txFailure||(txFailure=newSQLError(err))}0===--waiting&&(txFailure?tx.abort(txFailure):tx.executes.length>0?tx.run():tx.finish())}},i=0,mycbmap={};i<batchExecutes.length;)request=batchExecutes[i],qid=request.qid,mycbmap[qid]={success:handlerFor(i,!0),error:handlerFor(i,!1)},tropts.push({qid:qid,sql:request.sql,params:request.params}),i++;mycb=function(result){var q,r,res,type,_i,_len;for(_i=0,_len=result.length;_len>_i;_i++)r=result[_i],type=r.type,qid=r.qid,res=r.result,q=mycbmap[qid],q&&q[type]&&q[type](res)},cordova.exec(mycb,null,"SQLitePlugin","backgroundExecuteSqlBatch",[{dbargs:{dbname:this.db.dbname},executes:tropts}])},SQLitePluginTransaction.prototype.abort=function(txFailure){var failed,succeeded,tx;this.finalized||(tx=this,succeeded=function(tx){txLocks[tx.db.dbname].inProgress=!1,tx.db.startNextTransaction(),tx.error&&tx.error(txFailure)},failed=function(tx,err){txLocks[tx.db.dbname].inProgress=!1,tx.db.startNextTransaction(),tx.error&&tx.error(newSQLError("error while trying to roll back: "+err.message,err.code))},this.finalized=!0,this.txlock?(this.addStatement("ROLLBACK",[],succeeded,failed),this.run()):succeeded(tx))},SQLitePluginTransaction.prototype.finish=function(){var failed,succeeded,tx;this.finalized||(tx=this,succeeded=function(tx){txLocks[tx.db.dbname].inProgress=!1,tx.db.startNextTransaction(),tx.success&&tx.success()},failed=function(tx,err){txLocks[tx.db.dbname].inProgress=!1,tx.db.startNextTransaction(),tx.error&&tx.error(newSQLError("error while trying to commit: "+err.message,err.code))},this.finalized=!0,this.txlock?(this.addStatement("COMMIT",[],succeeded,failed),this.run()):succeeded(tx))},SQLitePluginTransaction.prototype.abortFromQ=function(sqlerror){this.error&&this.error(sqlerror)},dblocations=["docs","libs","nosync"],SQLiteFactory={opendb:argsArray(function(args){var dblocation,errorcb,first,okcb,openargs;return args.length<1?null:(first=args[0],openargs=null,okcb=null,errorcb=null,first.constructor===String?(openargs={name:first},args.length>=5&&(okcb=args[4],args.length>5&&(errorcb=args[5]))):(openargs=first,args.length>=2&&(okcb=args[1],args.length>2&&(errorcb=args[2]))),dblocation=openargs.location?dblocations[openargs.location]:null,openargs.dblocation=dblocation||dblocations[0],openargs.createFromLocation&&1===openargs.createFromLocation&&(openargs.createFromResource="1"),openargs.androidDatabaseImplementation&&2===openargs.androidDatabaseImplementation&&(openargs.androidOldDatabaseImplementation=1),openargs.androidLockWorkaround&&1===openargs.androidLockWorkaround&&(openargs.androidBugWorkaround=1),new SQLitePlugin(openargs,okcb,errorcb))}),deleteDb:function(first,success,error){var args,dblocation;if(args={},first.constructor===String)args.path=first,args.dblocation=dblocations[0];else{if(!first||!first.name)throw new Error("Please specify db name");args.path=first.name,dblocation=first.location?dblocations[first.location]:null,args.dblocation=dblocation||dblocations[0]}return delete SQLitePlugin.prototype.openDBs[args.path],cordova.exec(success,error,"SQLitePlugin","delete",[args])}},root.sqlitePlugin={sqliteFeatures:{isSQLitePlugin:!0},openDatabase:SQLiteFactory.opendb,deleteDatabase:SQLiteFactory.deleteDb}}).call(this);